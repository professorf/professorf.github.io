/*
 * maze.js: 
 *     ProfessorF's original implementation of a recursive descent 
 *     maze generation algorithm. This will be used as the basis
 *     for a variety of 3D maze games.
 *
 * Author : Nick V. Flor (nickflor@mentalsystemsinc.com)
 * License: GNU General Purpose License, version 3 (GPLv3)
 *          https://www.gnu.org/licenses/gpl-3.0.html
 * 
 * Date: November 22, 2020
 * 
 */

/*
 *
 * MazeObject: 
 *      A high-level structure to hold & describe a maze. 
 *
 */
function MazeObject(M, EntCell, ExiCell, W, H) { // 
    this.Maze     = M       // Maze representation as 4-bit binary walls
    this.EntryRC  = EntCell // Entry Cell [row column]
    this.ExitRC   = ExiCell // Exit  Cell[row column]
    this.Width    = W       // Number of cells across in the maze
    this.Height   = H       // Number of cells tall in the maze
    this.Solution = null    // Link to solution (generated by findPath())
}

/*
 *
 * createSolidMaze:
 *     Initializes a maze with all walls closed.
 * 
 * Entry: (Maze Dimensions)
 *     CellsAc: # of cells across in the maze
 *     CellsDn: # of cells down   in the maze
 *
 * Creates:
 *     A two dimensional matrix with each item denoting a cell's wall states.
 *     A cell is represented as four bits, North (hi), West, East, South (lobit)
 *     Thus a cell with all walls is denoted as: 0b1111,
 *     And a cell with no walls is denoted by: 0b0000.
 *     Last example, a cell with no west and east walls: 0b1001. 
 * 
 * Exit:  
 *     Maze (2d matrix) with cells set as described above.
 */
function createSolidMaze(CellsAc, CellsDn) { 
    let Maze    = [] // Create an empty maze

    for (let row=0; row<CellsDn; row++) {
        let MazeRow = []
        for (let col=0; col<CellsAc; col++) { // Init one row of the Maze
            let InitState = 0b1111            // Each cell All walled off
            MazeRow.push(InitState)        
        }
        Maze.push(MazeRow) // Add the row
    }

    return Maze
}

/*
 * openMazeEntryExit:
 *     Opens the walls for the maze cell's entry and exit points.
 * 
 * Entry: 
 *     Maze Object, which contains Entry & Exit Row,Columns (EntryRC, ExitRC).
 * 
 * Algorithm:
 *    Checks for a row or column boundary and opens up the appropriate wall.
 *
 * Exit: (in passed MazeObj)
 *    MazeObj.Maze entry and exit cells with appropriate walls opened.
 *
 */
function openMazeEntryExit(MazeObj) {
    let Maze=MazeObj.Maze        

    // Get the Entry and Exit row & columns.
    let EntRow=MazeObj.EntryRC[0] 
    let EntCol=MazeObj.EntryRC[1]
    let ExiRow=MazeObj.ExitRC [0]
    let ExiCol=MazeObj.ExitRC [1]

    // Get the Entry and Exit cells and set row & column boundaries.
    let EntCel=Maze[EntRow][EntCol]
    let ExiCel=Maze[ExiRow][ExiCol]
    let BotRow=MazeObj.Height-1
    let LstCol=MazeObj.Width-1

    // Open up the appropriate cell wall depending on boundaries.
    if (EntRow==0)      EntCel&=0b0111 // Entered from top perimeter
    if (EntRow==BotRow) EntCel&=0b1110 // Entered from bottom
    if (EntCol==0)      EntCel&=0b1011 // Entered from left
    if (EntCol==LstCol) EntCel&=0b1101 // Entered from right 

    if (ExiRow==0)      ExiCel&=0b0111 // Entered from top perimeter
    if (ExiRow==BotRow) ExiCel&=0b1110 // Entered from bottom
    if (ExiCol==0)      ExiCel&=0b1011 // Entered from left
    if (ExiCol==LstCol) ExiCel&=0b1101 // Entered from right 

    // Insert the updated cell
    Maze[EntRow][EntCol]=EntCel
    Maze[ExiRow][ExiCol]=ExiCel
}

/*
 * drawOneCell:
 *     Given a cell value, which encodes walls, returns an character
 *     representation of the cell.
 *
 * Entry:
 *     CellCode: the value of a cell, with the wall-bit encoding (0bNWES)
 * 
 * Algorithm Details:
 *     I would prefer a wall using the ascii upperscore character as follows:
 *     _
 *    | |
 *     â€¾ 
 *
 *     But the debug console doesn't display upperscore characters properly.
 *     So a cell is represented as a 5x3 character array:
 *     +---+
 *     |   |
 *     +---+ 
 *
 * Exit:
 *     Returns a 3x5 2D character matrix depicting a cell as described above. 
 */
var MazeCharCellW=5 // constants for mazes drawns as characters
var MazeCharCellH=3 // Width=5, Height=3
function drawCell(CellCode) { // cell code
let Cell, Top, Left, Right, Bottom

    Cell=[]

    // Add appropriate characters depending on whether or not there is a wall
    if (CellCode & 0b1000) Top    = "---"; else Top    = "   "
    if (CellCode & 0b0100) Left   = "|"  ; else Left   = " "
    if (CellCode & 0b0010) Right  = "|"  ; else Right  = " "
    if (CellCode & 0b0001) Bottom = "---"; else Bottom = "   "
    Cell.push("+"  +  Top   + "+")
    Cell.push(Left + "   "  + Right)
    Cell.push("+"  + Bottom + "+")

    return Cell
}

/*
 * drawMaze:
 *     Draws an entire maze as a set of characters.
 *     You should replace this with your own 2D or 3D maze drawing routine.
 * 
 * Entry:
 *     Maze: A 2D maze arrays whose cell values are bits denoting walls
 *
 * Algorithm:
 *     Accumulate the character representations of all the cell walls,
 *     then print out the character, removing the redundand size and
 *     redundant top walls.
 * 
 * Exit:
 *     Character maze depicted as characters on the debug console.
 */
function drawMaze(Maze) {
    let MazeImg=[]

    // Accumulate all cell images for the maze
    for (let rows in Maze) {
        let TopPart = ""
        let MidPart = ""
        let BotPart = ""
        for (let cols in Maze[rows]) {
            let ImgBlock=drawCell(Maze[rows][cols]) // draw one cell image
            TopPart+=ImgBlock[0] 
            MidPart+=ImgBlock[1] 
            BotPart+=ImgBlock[2] 
        }
        MazeImg.push(TopPart)
        MazeImg.push(MidPart)
        MazeImg.push(BotPart)
    }

    // Now print out the character maze
    // But do not print out top  walls, aside from the first top  wall.
    // And do not print out left walls, aside from the first left wall.
    // The reason is that cells share both bottom-top walls & right-left walls 
    for (let rows=0; rows<MazeImg.length; rows++) {
        // handle not drawing all top walls
        if (rows!=0 && (rows % MazeCharCellH)==0) continue

        // Draw the maze one line at a time
        let MazeLine=""

        for (let cols=0; cols<MazeImg[rows].length; cols++) {
            // Handle not drawing all left walls     
            if (cols!=0 && (cols % MazeCharCellW)==0) continue
            MazeLine+=MazeImg[rows][cols]
        }
        console.log(MazeLine)
        // console.log(MazeImg[rows])             // old fast way
    }
}

/*
 * findPath:
 *     Given a "solid" maze with an entry and exit cell, 
 *     find a path from entry cell to exit cell.
 * 
 * Entry:
 *     MazeObj    -- A maze object.
 *     CurrCellRC -- The row and column of the current cell.
 *                   The first time this is called, it is MazeObj.EntryRC,
 *                   and is recursively changed.
 * 
 * Exit:
 *     MazeObj.Maze updated with a maze & 
 *     a path from MazeObj.EntryRC to MazeObj.ExitRC
 */
function findPath(MazeObj, CurrCellRC, Steps) { // curr and dest are [row, col]
// Definitions
let Maze, DestCellRC
let CurrCell, CurrRow, CurrCol
let NextCell, NextRow, NextCol, NextCellRC
let Walls, RandWall, WallPick

//  Easy References
    Maze      = MazeObj.Maze   // Maze structure 
    DestCellRC= MazeObj.ExitRC // Destination Cell

//  Save solution if at destination
    if (CurrCellRC[0]==DestCellRC[0] && CurrCellRC[1]==DestCellRC[1]) {
        MazeObj.Solution=Steps // save solution found, if multiple, then last
        // Uncomment below to limit paths to exit (less hallways)
        // return // DONE removed 11/25/2020, continue recursing around soln
    }

//  Try opening a random wall
    CurrRow  = CurrCellRC[0]                  // get walls of cell
    CurrCol  = CurrCellRC[1] 
    CurrCell = Maze[CurrRow][CurrCol]   

    Walls=[]                                  // push all walls in the cell  
    if (CurrCell & 0b1000) Walls.push(0b1000)  
    if (CurrCell & 0b0100) Walls.push(0b0100)
    if (CurrCell & 0b0010) Walls.push(0b0010)
    if (CurrCell & 0b0001) Walls.push(0b0001)

    while (Walls.length>0) { // Try every unopened wall & unvisited cell
        RandWall = Math.floor(Math.random()*Walls.length) // Pick a random wall
        WallPick = Walls.splice(RandWall,1)               // Splice out

        // Find the row and column of the cell next to the WallPick
        NextRow = CurrCellRC[0]              // Start at the current cell
        NextCol = CurrCellRC[1]
        if      (WallPick==0b1000) --NextRow // Picked North Wall, so Up    Cell
        else if (WallPick==0b0100) --NextCol // Picked West  Wall, so Left  Cell
        else if (WallPick==0b0010) ++NextCol // Picked East  Wall, so Right Cell
        else if (WallPick==0b0001) ++NextRow // Picked South Wall, so Down  Cell
        
        // Check & skip if past boundaries
        if (NextCol<0 || NextCol>=MazeObj.Width || NextRow<0 || NextRow>=MazeObj.Height) 
            continue; // skip and try another cell
        
        // Get the adjacent cell to the wall we selected
        NextCellRC =     [NextRow, NextCol]
        NextCell   = Maze[NextRow][NextCol]
        
        // Check & skip if cell already visited indicated by NOT all walls (0b1111)
        if (NextCell!=0b1111) continue // NB: I originally forgot this key line!

        // Open up adjacent currcell and nextcell walls 
        if      (WallPick==0b1000) {CurrCell &= 0b0111; NextCell &= 0b1110}
        else if (WallPick==0b0100) {CurrCell &= 0b1011; NextCell &= 0b1101}
        else if (WallPick==0b0010) {CurrCell &= 0b1101; NextCell &= 0b1011}
        else if (WallPick==0b0001) {CurrCell &= 0b1110; NextCell &= 0b0111}
        Maze[CurrRow][CurrCol] = CurrCell
        Maze[NextRow][NextCol] = NextCell

        // Now save this next cell for the eventual solution & recursively try finding the exit
        NewSteps=Steps.slice() // Warning: slice copies subarray pointers
        NewSteps.push(NextCellRC)
        findPath(MazeObj, NextCellRC, NewSteps)
    }
}

/*
 * createMaze:
 *     Creates a maze of a specified dimension, & with entry and exit perimters.
 * 
 * Entry:
 *     CellsAc: The number of cells both across (default: "W"). 
 *     CellsDn: The number of cells down (default: "E").
 *              Other values are "N", and "S"
 *
 * Algorithm Details:
 *     Create a blank maze, 
 *     Pick random entry and exit points,
 *     Create a path from entry to exit, "fleshing out" the maze
 *     
 * Exit:
 *     Returns a MazeObject
 */
function createMaze(CellsAc, CellsDn, CEntry="W", CExit="E") {
// Declarations
let Maze
let RndCell, EntryCellRC, ExitCellRC
let i
let MObj

    // Create an empty maze
    Maze= createSolidMaze(CellsAc, CellsDn)
 
    let RandEntExi=false 
    if (RandEntExi) { // Code for choosing a random perimeter for entry & exit 
        let PChoices=["N", "W", "E", "S"] // Perimeter choices
        let PEntry= Math.floor(Math.random()*PChoices.length)
        let CEntry= PChoices[PEntry]
        PChoices.splice(PEntry, 1)        // remove that entry so exit is diff
        let PExit = Math.floor(Math.random()*PChoices.length)
        let CExit = PChoices[PExit]
    }

    // Pick a random perimeter cell not on the ends, ergo -2,+1 adjustments
    if (CEntry=="N" || CEntry=="S")
        RndCell=Math.floor(Math.random()*(CellsAc-2))+1
    else
        RndCell=Math.floor(Math.random()*(CellsDn-2))+1

    // Determine the row and column for the entry cell
    switch (CEntry) {
        case 'N': EntryCellRC = [0          , RndCell    ]; break;
        case 'W': EntryCellRC = [RndCell    , 0          ]; break;
        case 'E': EntryCellRC = [RndCell    , (CellsAc-1)]; break;
        case 'S': EntryCellRC = [(CellsDn-1), RndCell    ]; break;
    }

    // Pick a random perimeter cell not on the ends, ergo -2,+1 adjustments
    if (CExit=="N" || CExit=="S")
        RndCell=Math.floor(Math.random()*(CellsAc-2))+1
    else
        RndCell=Math.floor(Math.random()*(CellsDn-2))+1

    // Determine the row and column for the entry cell
    switch (CExit) {
        case 'N': ExitCellRC = [0          , RndCell    ]; break;
        case 'W': ExitCellRC = [RndCell    , 0          ]; break;
        case 'E': ExitCellRC = [RndCell    , (CellsAc-1)]; break;
        case 'S': ExitCellRC = [(CellsDn-1), RndCell    ]; break;
    }

    // Now create the maze super object with all the objects just created
    MObj = new MazeObject(Maze, EntryCellRC, ExitCellRC, CellsAc, CellsDn)

    // Find and create the paths in the maze from entry toe xit
    findPath(MObj, MObj.EntryRC, [MObj.EntryRC])

    // Open up the maze entry and exit walls
    // (Need to be closed for findPath to work properly)
    openMazeEntryExit(MObj)

    return MObj
}

/* Sample Usage
var MObj=createMaze(10,10)
console.log("Entry:"+MObj.EntryRC+","+MObj.ExitRC)
drawMaze(MObj.Maze)
draw3DMaze(MObj)
console.log("Finished Maze (Entry/Exit Open):"+MObj.Solution)
if (!MObj.Solution) console.log("No solution found") // rare, but redo if none
brake=0
*/